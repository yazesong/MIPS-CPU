#########################################################################
# Minisys-1A BIOS (Final Hardware Version)
# 适配硬件中断入口：0x0000F000
#########################################################################

# =======================================================================
# 1. 复位处理程序 (Reset Handler) - 物理地址 0x0000
# =======================================================================
.text 0x0000
_startup:
    j   _bios_init          # 跳转到初始化代码
    nop

# =======================================================================
# 2. BIOS 初始化主体
# 注意：我们将初始化代码放在 0x0200，避开复位区，也远低于中断区(0xF000)
# =======================================================================
.text 0x0200
_bios_init:
    # -----------------------------------------------------------
    # 2.1 初始化寄存器
    # -----------------------------------------------------------
    addu    $zero, $zero, $zero # 确保 $0 为 0
    addu    $t0, $zero, $zero

    # -----------------------------------------------------------
    # 2.2 初始化堆栈指针 ($sp)
    # 设为 0x00003FFC (假设 RAM 低端 16KB 处，防止与高位中断区冲突)
    # -----------------------------------------------------------
    lui     $sp, 0x0000
    ori     $sp, $sp, 0x3FFC
    addu    $fp, $sp, $zero

    # -----------------------------------------------------------
    # 2.3 关看门狗 (端口 0xFFFFFC50)
    # -----------------------------------------------------------
    lui     $t0, 0xFFFF
    ori     $t0, $t0, 0xFC50
    sw      $zero, 0($t0)       # 写入 0

    # -----------------------------------------------------------
    # 2.4 初始化 LED (端口 0xFFFFFC60)
    # -----------------------------------------------------------
    lui     $t0, 0xFFFF
    ori     $t0, $t0, 0xFC60
    addiu   $t1, $zero, 1
    sw      $t1, 0($t0)         # 点亮 LED[0]

    # -----------------------------------------------------------
    # 2.5 开启中断 (CP0 Status #12)
    # -----------------------------------------------------------
    mfc0    $t0, $12, 0
    ori     $t0, $t0, 0x0001    # IE=1
    mtc0    $t0, $12, 0

    # -----------------------------------------------------------
    # 2.6 跳转到用户程序 (main)
    # -----------------------------------------------------------
    jal     main
    nop

_halt:
    j       _halt
    nop

# =======================================================================
# 3. 用户程序 (User Program)
# 放在 0x0400，位于 BIOS 和中断区之间
# =======================================================================
.text 0x0400
main:
    # 示例：流水灯
    addiu   $s0, $zero, 1       # $s0 = 1
_user_loop:
    lui     $t0, 0xFFFF
    ori     $t0, $t0, 0xFC60    # LED 地址
    sw      $s0, 0($t0)

    sll     $s0, $s0, 1         # 左移
    bne     $s0, $zero, _delay_start
    addiu   $s0, $zero, 1       # 重置

_delay_start:
    lui     $t1, 0x0005         # 延时
_delay:
    addiu   $t1, $t1, -1
    bne     $t1, $zero, _delay
    nop
    j       _user_loop
    nop

# =======================================================================
# 4. 异常/中断入口 (Exception Vector)
# 必须与硬件定义的 interrupt_pc_out = 32'h0000F000 一致！
# =======================================================================
.text 0xF000            # <--- 这里修改为 0xF000
_exception_vector:
    # -----------------------------------------------------------
    # Step 1: 保存上下文 (Context Save)
    # -----------------------------------------------------------
    addiu   $sp, $sp, -128
    sw      $at, 0($sp)
    sw      $v0, 4($sp)
    sw      $a0, 8($sp)
    sw      $t0, 12($sp)
    sw      $t1, 16($sp)
    sw      $t2, 20($sp)
    sw      $t3, 24($sp)
    sw      $ra, 28($sp)

    # -----------------------------------------------------------
    # Step 2: 获取异常信息
    # -----------------------------------------------------------
    mfc0    $t0, $13, 0         # Cause
    mfc0    $t1, $14, 0         # EPC

    # -----------------------------------------------------------
    # Step 3: 分发处理 (ExcCode bits 6-2)
    # -----------------------------------------------------------
    andi    $t2, $t0, 0x007C
    srl     $t2, $t2, 2

    # 外部中断 (ExcCode == 0)
    bne     $t2, $zero, _check_syscall
    jal     hardware_interrupt_service
    nop
    j       _isr_exit
    nop

_check_syscall:
    # Syscall (ExcCode == 8)
    addiu   $t3, $zero, 8
    bne     $t2, $t3, _other_exception
    jal     syscall_service
    nop
    j       _isr_exit
    nop

_other_exception:
    # 其他异常：EPC + 4 跳过指令
    addiu   $t1, $t1, 4
    mtc0    $t1, $14, 0

_isr_exit:
    # -----------------------------------------------------------
    # Step 5: 恢复上下文 (Context Restore)
    # -----------------------------------------------------------
    lw      $ra, 28($sp)
    lw      $t3, 24($sp)
    lw      $t2, 20($sp)
    lw      $t1, 16($sp)
    lw      $t0, 12($sp)
    lw      $a0, 8($sp)
    lw      $v0, 4($sp)
    lw      $at, 0($sp)
    addiu   $sp, $sp, 128

    # -----------------------------------------------------------
    # Step 6: 返回
    # -----------------------------------------------------------
    eret

# -----------------------------------------------------------
# 服务子程序桩
# -----------------------------------------------------------
hardware_interrupt_service:
    jr      $ra
    nop

syscall_service:
    mfc0    $k0, $14, 0
    addiu   $k0, $k0, 4
    mtc0    $k0, $14, 0
    jr      $ra
    nop